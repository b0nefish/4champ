//
//  RadioPresenter.swift
//  4champ
//
//  Created by Aleksi Sitomaniemi on 25/06/2018.
//  Copyright (c) 2018 Aleksi Sitomaniemi. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import MediaPlayer

protocol RadioPresentationLogic
{
  func presentControlStatus(status: RadioStatus)
  func presentChannelBuffer(buffer: [MMD])
  func presentPlaybackTime(length: Int, elapsed: Int)
}

class RadioPresenter: RadioPresentationLogic
{
  weak var viewController: RadioDisplayLogic?
  
  // MARK: Do something
  func presentControlStatus(status: RadioStatus) {
    let vm = Radio.Control.ViewModel(status: status)
    DispatchQueue.main.async {
      self.viewController?.displayControlStatus(viewModel: vm)
    }
  }
  
  func presentChannelBuffer(buffer: [MMD]) {
    var nextUp: String?
    if buffer.count > 1 {
      nextUp = String.init(format: "Radio_NextUp".l13n(), buffer[1].name!, buffer[1].composer! )
    }
    
    let vm = Radio.ChannelBuffer.ViewModel(nowPlaying: buffer.first, nextUp: nextUp)
    DispatchQueue.main.async {
      self.viewController?.displayChannelBuffer(viewModel: vm)
    }
    
    if let currentMod = buffer.first {
      let infos = MPNowPlayingInfoCenter.default()
      let author = currentMod.composer
      let songName = String.init(format: "LockScreen_Playing".l13n(), currentMod.name!, currentMod.composer!)
      let playlistName = "LockScreen_Radio".l13n()
      
      let dict: [String: Any] =
      [ MPMediaItemPropertyAlbumTitle: playlistName,
        MPMediaItemPropertyTitle: songName,
        MPMediaItemPropertyArtist: author ?? "",
        MPMediaItemPropertyPlaybackDuration: NSNumber.init(value: modulePlayer.renderer.moduleLength()),
        MPNowPlayingInfoPropertyElapsedPlaybackTime: NSNumber.init(value: modulePlayer.renderer.currentPosition())
      ]
      infos.nowPlayingInfo = dict
    }
  }
  
  func presentPlaybackTime(length: Int, elapsed: Int) {
    let timeLeft = length - elapsed
    let seconds = timeLeft % 60
    let minutes = (timeLeft - seconds) / 60
    let timeString = String.init(format: "%d:%02d", minutes, seconds)
    let vm = Radio.Playback.ViewModel(timeLeft: timeString)
    DispatchQueue.main.async {
      self.viewController?.displayPlaybackTime(viewModel: vm)
    }
  }
}
//      - (void) postNPStatus
//        {
//          MPNowPlayingInfoCenter* playingInfoCenter = [MPNowPlayingInfoCenter defaultCenter];
//
//          if (playingInfoCenter) {
//
//            ModuleInfo* tempObject = [self getCurrentModuleInfo];
//            if (!tempObject || ![self isPlaying]) {
//              return;
//            } else {
//
//              NSMutableDictionary *songInfo = [[NSMutableDictionary alloc] init];
//
//              MPMediaItemArtwork *albumArt = [[MPMediaItemArtwork alloc] initWithImage: [UIImage imageNamed:@"albumart.png"]];
//
//
//              [songInfo setObject:playlistName forKey:MPMediaItemPropertyAlbumTitle];
//              [songInfo setObject:songName forKey:MPMediaItemPropertyTitle];
//              [songInfo setObject:author forKey:MPMediaItemPropertyArtist];
//              [songInfo setObject:albumArt forKey:MPMediaItemPropertyArtwork];
//
//              [songInfo setObject:[NSNumber numberWithInt:self.moduleLength] forKey:MPMediaItemPropertyPlaybackDuration];
//              [songInfo setObject:[NSNumber numberWithInt:self.currentPosition] forKey:MPNowPlayingInfoPropertyElapsedPlaybackTime];
//
//              [playingInfoCenter setNowPlayingInfo:songInfo];
//
//              //Post the info also to watch, if available
//              AmpAppDelegate* appDelegate = (AmpAppDelegate*)[[UIApplication sharedApplication] delegate];
//
//              [appDelegate postNowPlayingToWatch:tempObject playList:_currentPlaylist];
//            }
